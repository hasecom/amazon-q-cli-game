import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import '../styles/Game.css';

// 漢字データ（画数ごとに分類）
const kanjiData = {
  // 1画の漢字
  1: ['一', '乙', '丨', '丶', '丿'],
  
  // 2画の漢字
  2: ['二', '十', '人', '入', '八', '几', '刀', '力', '又', '了'],
  
  // 3画の漢字
  3: ['三', '上', '下', '口', '山', '千', '川', '土', '大', '女', '子', '小', '夕', '丸', '才', '亡', '工'],
  
  // 4画の漢字
  4: ['四', '五', '六', '中', '手', '天', '日', '月', '木', '水', '火', '犬', '王', '正', '出', '本', '右', '左', '玉', '田', '白'],
  
  // 5画の漢字
  5: ['円', '王', '玉', '石', '田', '白', '目', '立', '古', '外', '平', '半', '母', '北', '用', '矢', '生', '世', '主', '代', '冬'],
  
  // 6画の漢字
  6: ['先', '名', '字', '年', '早', '気', '百', '竹', '糸', '耳', '虫', '村', '男', '町', '花', '見', '貝', '赤', '足', '車', '不'],
  
  // 7画の漢字
  7: ['赤', '足', '村', '男', '町', '花', '見', '貝', '車', '何', '作', '体', '弟', '皿', '空', '金', '雨', '青', '音', '草', '麦'],
  
  // 8画の漢字
  8: ['金', '雨', '青', '草', '音', '学', '空', '林', '社', '虫', '京', '国', '夜', '妹', '姉', '店', '明', '東', '歩', '画', '直'],
  
  // 9画の漢字
  9: ['思', '星', '活', '海', '科', '室', '首', '秋', '家', '真', '時', '茶', '計', '食', '点', '風', '前', '後', '南', '点', '室'],
  
  // 10画の漢字
  10: ['校', '高', '海', '活', '教', '馬', '魚', '鳥', '黄', '黒', '細', '週', '雪', '船', '組', '鳥', '料', '理', '野', '陽', '雲']
};

const Game = () => {
  // ゲームの設定
  const boardSize = 15; // ボードのサイズ
  const cellSize = 40; // セルのサイズ（ピクセル）
  const gameLoopRef = useRef(null);
  const kanjiTimerRef = useRef(null);
  const gameBoardRef = useRef(null);
  const gameContainerRef = useRef(null);

  // ゲームの状態
  const [currentStrokeCount, setCurrentStrokeCount] = useState(1); // 現在の画数
  const [currentKanji, setCurrentKanji] = useState(""); // 現在取るべき漢字
  const [playerPosition, setPlayerPosition] = useState({ x: 1, y: 1 });
  const [gameBoard, setGameBoard] = useState([]);
  const [gameOver, setGameOver] = useState(false);
  const [gameWon, setGameWon] = useState(false);
  const [level, setLevel] = useState(1);
  const [score, setScore] = useState(0);
  const [remainingKanji, setRemainingKanji] = useState(0);
  const [highlightCells, setHighlightCells] = useState([]);
  const [isMobile, setIsMobile] = useState(false);
  const [viewportOffset, setViewportOffset] = useState({ x: 0, y: 0 });
  const [enemies, setEnemies] = useState([]);
  const [nextKanjiTimer, setNextKanjiTimer] = useState(null);
  const [playerMoveCount, setPlayerMoveCount] = useState(0); // プレイヤーの移動回数をカウント
  const [kanjiActive, setKanjiActive] = useState(true); // 漢字が取得可能かどうか
  const [lastPlayerMoveTime, setLastPlayerMoveTime] = useState(0); // プレイヤーの最後の移動時間

  // 指定された画数の漢字をランダムに選択する関数
  const selectRandomKanji = useCallback((strokeCount) => {
    // 指定された画数の漢字リストを取得
    const kanjiList = kanjiData[strokeCount];
    
    // 漢字リストが存在しない場合は空文字を返す
    if (!kanjiList || kanjiList.length === 0) {
      return '';
    }
    
    // ランダムなインデックスを生成
    const randomIndex = Math.floor(Math.random() * kanjiList.length);
    
    // ランダムな漢字を返す
    return kanjiList[randomIndex];
  }, []);

  // 次に取るべき漢字を表示
  const getNextKanjiText = () => {
    if (currentStrokeCount > 10) {
      return "すべて集めました！";
    }
    return `次の漢字: ${currentKanji}（${currentStrokeCount}画）`;
  };
  
  // 漢字が取得可能になるまでの残り時間を表示
  const getTimerText = () => {
    if (!nextKanjiTimer) return "";
    
    const remainingTime = Math.max(0, Math.ceil((nextKanjiTimer - Date.now()) / 1000));
    return `次の漢字のヒントまで: ${remainingTime}秒`;
  };

  // 漢字ヒントタイマーを開始する関数
  const startKanjiTimer = useCallback(() => {
    // 漢字を非アクティブにする
    setKanjiActive(false);
    
    // 30秒後に漢字をアクティブにする
    const timerEnd = Date.now() + 30000; // 30秒
    setNextKanjiTimer(timerEnd);
    
    // 既存のタイマーをクリア
    if (kanjiTimerRef.current) {
      clearTimeout(kanjiTimerRef.current);
    }
    
    // 新しいタイマーを設定
    kanjiTimerRef.current = setTimeout(() => {
      setKanjiActive(true);
      setNextKanjiTimer(null);
    }, 30000);
  }, []);

  // プレイヤーの周囲のセルをハイライトする関数
  const updateHighlightCells = useCallback((position) => {
    const { x, y } = position;
    const newHighlightCells = [];
    
    // 上下左右のセルをハイライト
    const directions = [
      { x: 0, y: -1 }, // 上
      { x: 0, y: 1 },  // 下
      { x: -1, y: 0 }, // 左
      { x: 1, y: 0 }   // 右
    ];
    
    for (const dir of directions) {
      const newX = x + dir.x;
      const newY = y + dir.y;
      
      // ボード内かつ壁でない場所
      if (
        newX >= 0 && 
        newX < boardSize && 
        newY >= 0 && 
        newY < boardSize && 
        gameBoard && 
        gameBoard[newY] && 
        (!gameBoard[newY][newX] || gameBoard[newY][newX].type !== 'wall')
      ) {
        newHighlightCells.push({ x: newX, y: newY });
      }
    }
    
    setHighlightCells(newHighlightCells);
  }, [boardSize, gameBoard]);

  // プレイヤーと敵を同時に移動させる関数
  const movePlayerAndEnemies = useCallback((newX, newY) => {
    // 移動先が有効かチェック
    if (
      newX >= 0 && 
      newX < boardSize && 
      newY >= 0 && 
      newY < boardSize && 
      gameBoard && 
      gameBoard[newY]
    ) {
      const targetCell = gameBoard[newY][newX];
      
      // 壁には移動できない
      if (targetCell && targetCell.type === 'wall') {
        return;
      }
      
      // 敵のセルの場合
      if (targetCell && targetCell.type === 'enemy') {
        setGameOver(true);
        return;
      }
      
      // 漢字のセルの場合
      if (targetCell && targetCell.type === 'kanji') {
        // 現在の画数の漢字の場合のみ取得可能
        if (targetCell.strokeCount === currentStrokeCount) {
          // 正しい画数の漢字を取得
          setScore(score + currentStrokeCount * 100); // 画数に応じたスコア
          setRemainingKanji(remainingKanji - 1);
          setCurrentStrokeCount(currentStrokeCount + 1);
          
          // 次の漢字を選択
          const nextKanji = selectRandomKanji(currentStrokeCount + 1);
          setCurrentKanji(nextKanji);
          
          // 漢字ヒントタイマーを開始（最初の漢字以外）
          if (currentStrokeCount > 1 || remainingKanji > 1) {
            startKanjiTimer();
          }
          
          // すべての漢字を集めたらレベルクリア
          if (remainingKanji - 1 <= 0) {
            setGameWon(true);
            return;
          }
        } else {
          // 間違った画数の漢字を取ろうとした場合はゲームオーバー
          setGameOver(true);
          return;
        }
      }
      
      // 現在のゲームボードの状態をコピー
      const newBoard = [...gameBoard];
      const newEnemies = [...enemies];
      
      // 1. プレイヤーの移動
      // 現在位置のプレイヤーを削除
      newBoard[playerPosition.y][playerPosition.x] = null;
      
      // 新しい位置にプレイヤーを配置
      newBoard[newY][newX] = { type: 'player' };
      
      // プレイヤーの移動回数を更新
      const newMoveCount = playerMoveCount + 1;
      setPlayerMoveCount(newMoveCount);
      
      // 2. 敵の移動（プレイヤーが2回移動するごとに敵が1回移動）
      if (newMoveCount % 2 === 0) {
        for (let i = 0; i < newEnemies.length; i++) {
          const enemy = newEnemies[i];
          
          // 現在の敵の位置をボードから削除
          if (
            enemy.x >= 0 && 
            enemy.x < boardSize && 
            enemy.y >= 0 && 
            enemy.y < boardSize &&
            newBoard[enemy.y][enemy.x] && 
            newBoard[enemy.y][enemy.x].type === 'enemy'
          ) {
            // 敵が漢字の上にいた場合、漢字を復元
            if (newBoard[enemy.y][enemy.x].onKanji) {
              newBoard[enemy.y][enemy.x] = newBoard[enemy.y][enemy.x].onKanji;
            } else {
              newBoard[enemy.y][enemy.x] = null;
            }
          }
          
          // プレイヤーに近づく最適な方向を見つける
          let bestDirection = { x: 0, y: 0 };
          let minDistance = Number.MAX_VALUE;
          
          // 可能な移動方向
          const directions = [
            { x: 0, y: -1 }, // 上
            { x: 0, y: 1 },  // 下
            { x: -1, y: 0 }, // 左
            { x: 1, y: 0 }   // 右
          ];
          
          // プレイヤーに最も近づく方向を選択（新しいプレイヤー位置に基づく）
          for (const dir of directions) {
            const nextX = enemy.x + dir.x;
            const nextY = enemy.y + dir.y;
            
            // ボード内かつ壁でなく、他の敵もいない場所
            if (
              nextX >= 0 && 
              nextX < boardSize && 
              nextY >= 0 && 
              nextY < boardSize
            ) {
              const cell = newBoard[nextY][nextX];
              if (!cell || 
                  (cell.type !== 'wall' && cell.type !== 'enemy') || 
                  cell.type === 'player') {
                
                // 新しいプレイヤー位置までの距離を計算
                const distance = Math.abs(nextX - newX) + Math.abs(nextY - newY);
                
                // より近い方向を選択
                if (distance < minDistance) {
                  minDistance = distance;
                  bestDirection = dir;
                }
              }
            }
          }
          
          // 移動先の座標
          const nextX = enemy.x + bestDirection.x;
          const nextY = enemy.y + bestDirection.y;
          
          // 移動先が有効な場合のみ移動
          if (
            nextX >= 0 && 
            nextX < boardSize && 
            nextY >= 0 && 
            nextY < boardSize
          ) {
            const targetCell = newBoard[nextY][nextX];
            
            // プレイヤーに当たった場合
            if (targetCell && targetCell.type === 'player') {
              setGameOver(true);
              return;
            }
            
            // 移動先が壁でなく、他の敵もいない場合
            if (!targetCell || (targetCell.type !== 'wall' && targetCell.type !== 'enemy')) {
              // 敵を新しい位置に移動
              newEnemies[i] = { ...enemy, x: nextX, y: nextY };
              
              // 移動先に漢字がある場合は、敵が漢字の上に乗る（漢字は消さない）
              if (targetCell && targetCell.type === 'kanji') {
                newBoard[nextY][nextX] = { 
                  type: 'enemy',
                  speed: enemy.speed,
                  onKanji: targetCell // 漢字の情報を保持
                };
              } else {
                newBoard[nextY][nextX] = { 
                  type: 'enemy',
                  speed: enemy.speed
                };
              }
            } else {
              // 移動できない場合は元の位置に戻す
              newBoard[enemy.y][enemy.x] = { 
                type: 'enemy',
                speed: enemy.speed
              };
            }
          } else {
            // ボード外の場合は元の位置に戻す
            newBoard[enemy.y][enemy.x] = { 
              type: 'enemy',
              speed: enemy.speed
            };
          }
        }
      }
      
      // 3. 状態を更新
      setGameBoard(newBoard);
      setPlayerPosition({ x: newX, y: newY });
      setEnemies(newEnemies);
      
      // 4. 移動可能なセルを更新
      updateHighlightCells({ x: newX, y: newY });
      
      // 5. プレイヤーの最終移動時間を更新
      setLastPlayerMoveTime(Date.now());
    }
  }, [
    boardSize, 
    gameBoard, 
    playerPosition, 
    enemies, 
    currentStrokeCount, 
    remainingKanji, 
    score, 
    selectRandomKanji, 
    startKanjiTimer, 
    updateHighlightCells,
    playerMoveCount
  ]);

  // レベルの初期化
  const initializeLevel = useCallback(() => {
    // ゲームの初期化処理
    setGameBoard([]);
    setPlayerPosition({ x: 1, y: 1 });
    setGameOver(false);
    setGameWon(false);
    setPlayerMoveCount(0);
  }, []);

  // コンポーネントがマウントされたときの処理
  useEffect(() => {
    initializeLevel();
  }, [initializeLevel]);

  return (
    <div className="game-container">
      <h1>漢字迷路ゲーム</h1>
      <div className="game-info">
        <p>レベル: {level}</p>
        <p>スコア: {score}</p>
        <p>{getNextKanjiText()}</p>
        <p>{getTimerText()}</p>
      </div>
      <div className="game-board">
        {/* ゲームボードの表示 */}
      </div>
    </div>
  );
};

export default Game;
